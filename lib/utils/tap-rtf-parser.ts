// eFondaMental Platform - TAP RTF File Parser
// Parses RTF files generated by TAP software (Zimmermann & Fimm)
// Supports: TAP-Attention soutenue, TAP-Flexibilité

import type {
  TapTestMetadata,
  AttentionSoutenueRow,
  FlexibiliteRow,
  FlexibiliteGlobalIndices,
} from '@/lib/questionnaires/schizophrenia/initial/neuropsy/tap/types';

export type TapTestType = 'attention_soutenue' | 'flexibilite';

export interface TapParseResult {
  testType: TapTestType;
  typeTest: string;
  metadata: TapTestMetadata;
  attentionRows?: AttentionSoutenueRow[];
  flexibiliteRows?: FlexibiliteRow[];
  globalIndices?: FlexibiliteGlobalIndices;
}

// ── RTF hex escape → Unicode character ──────────────────────────────────────
function decodeRtfHex(text: string): string {
  return text.replace(/\\'([0-9a-f]{2})/gi, (_, hex) =>
    String.fromCharCode(parseInt(hex, 16))
  );
}

// ── Strip RTF to plain text (for metadata + non-table content) ──────────────
function stripRtfToPlainText(rtf: string): string {
  let text = rtf;

  text = text.replace(/\{\\fonttbl[^}]*\}/g, '');
  text = text.replace(/\{\\colortbl[^}]*\}/g, '');
  text = text.replace(/\{\\stylesheet[^}]*\}/g, '');
  text = text.replace(/\{\\info[^}]*\}/g, '');
  text = text.replace(/\{\\\\?\*\\expandedcolortbl[^}]*\}/g, '');

  text = text.replace(/\\par\b/g, '\n');
  text = text.replace(/\\tab\b/g, '\t');
  text = text.replace(/\\line\b/g, '\n');

  text = decodeRtfHex(text);

  text = text.replace(/\\[a-z]+\d*\s?/gi, '');
  text = text.replace(/[{}]/g, '');

  // RTF uses trailing \ as paragraph break (shorthand for \par)
  text = text.replace(/\\\n/g, '\n');
  text = text.replace(/\\$/gm, '');

  text = text.replace(/\r\n/g, '\n');
  text = text.replace(/\r/g, '\n');
  text = text.replace(/\u00a0/g, ' ');

  return text.trim();
}

// ── Extract visible text from a single RTF cell segment ─────────────────────
function extractCellText(rtfSegment: string): string {
  let text = rtfSegment;

  // The actual cell content comes after the last \cfN control word
  const lastCfIdx = text.lastIndexOf('\\cf');
  if (lastCfIdx >= 0) {
    text = text.substring(lastCfIdx);
    text = text.replace(/^\\cf\d+\s*/, '');
  }

  text = decodeRtfHex(text);
  text = text.replace(/\\[a-z]+\d*\s?/gi, '');
  text = text.replace(/[{}]/g, '');
  text = text.replace(/\u00a0/g, ' ');
  text = text.replace(/[\r\n]+/g, ' ');
  text = text.replace(/\s+/g, ' ').trim();

  return text;
}

// ── Parse RTF table: extract cell values grouped into rows ──────────────────
function parseRtfTableRows(rtf: string): string[][] {
  const rows: string[][] = [];
  let currentRow: string[] = [];

  // Split on \cell and \row markers, keeping delimiters
  const parts = rtf.split(/(\\cell\b|\\lastrow\\row\b|\\row\b)/);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (/^\\cell\b/.test(part)) {
      const rawContent = i > 0 ? parts[i - 1] : '';
      currentRow.push(extractCellText(rawContent));
    } else if (/^\\(?:lastrow\\)?row\b/.test(part)) {
      if (currentRow.length > 0) {
        rows.push(currentRow);
        currentRow = [];
      }
    }
  }
  if (currentRow.length > 0) rows.push(currentRow);
  return rows;
}

// ── Metadata extraction from plain text lines ───────────────────────────────
function extractMetadata(lines: string[]): TapTestMetadata {
  const metadata: TapTestMetadata = {
    examinateur: null,
    date_passation: null,
    age: null,
    normes: null,
  };

  for (const line of lines) {
    const trimmed = line.trim();

    const examMatch = trimmed.match(/^Examinateur\s*:\s*(.+)/i);
    if (examMatch) { metadata.examinateur = examMatch[1].trim(); continue; }

    const dateMatch = trimmed.match(/^Date de passation\s*:\s*(.+)/i);
    if (dateMatch) { metadata.date_passation = dateMatch[1].trim(); continue; }

    const ageMatch = trimmed.match(/^Age\s*:\s*(\d+)/i);
    if (ageMatch) { metadata.age = parseInt(ageMatch[1], 10); continue; }

    const normesMatch = trimmed.match(/^Normes\s*:\s*(.+)/i);
    if (normesMatch) { metadata.normes = normesMatch[1].trim(); continue; }
  }

  return metadata;
}

function parseNumber(val: string): number | null {
  const trimmed = val.trim();
  if (!trimmed || trimmed === '-' || trimmed === '–') return null;
  const normalized = trimmed.replace(',', '.');
  const num = parseFloat(normalized);
  return isNaN(num) ? null : num;
}

function parseInteger(val: string): number | null {
  const num = parseNumber(val);
  return num !== null ? Math.round(num) : null;
}

function detectTestType(text: string): { type: TapTestType; typeTest: string } | null {
  if (/TAP[- ]Attention soutenue/i.test(text)) {
    return { type: 'attention_soutenue', typeTest: 'Couleur ou forme' };
  }
  if (/TAP[- ]Flexibilit/i.test(text)) {
    return { type: 'flexibilite', typeTest: 'Alternance lettres et chiffres' };
  }
  return null;
}

// ── Build typed rows from raw cell arrays ───────────────────────────────────

function isAttentionCondition(text: string): boolean {
  return /^(0-5|5-10|10-15|total)/i.test(text.trim());
}

function isFlexCondition(text: string): boolean {
  return /^(Avec |Sans |Lettres|Chiffres|Total)/i.test(text.trim());
}

function buildAttentionRows(tableRows: string[][]): AttentionSoutenueRow[] {
  const result: AttentionSoutenueRow[] = [];
  for (const cells of tableRows) {
    if (cells.length < 12) continue;
    if (!isAttentionCondition(cells[0])) continue;
    result.push({
      condition: cells[0].trim(),
      moyenne: parseInteger(cells[1]),
      mediane: parseInteger(cells[2]),
      percentile_mediane: parseInteger(cells[3]),
      ecart_type: parseInteger(cells[4]),
      percentile_et: parseInteger(cells[5]),
      correctes: parseInteger(cells[6]),
      fausses: parseInteger(cells[7]),
      percentile_fausses: parseInteger(cells[8]),
      omises: parseInteger(cells[9]),
      percentile_omises: parseInteger(cells[10]),
      aberrantes: parseInteger(cells[11]),
    });
  }
  return result;
}

function buildFlexibiliteRows(tableRows: string[][]): FlexibiliteRow[] {
  const result: FlexibiliteRow[] = [];
  for (const cells of tableRows) {
    if (cells.length < 10) continue;
    if (!isFlexCondition(cells[0])) continue;
    result.push({
      condition: cells[0].trim(),
      moyenne: parseInteger(cells[1]),
      mediane: parseInteger(cells[2]),
      percentile_mediane: parseInteger(cells[3]),
      ecart_type: parseInteger(cells[4]),
      percentile_et: parseInteger(cells[5]),
      correctes: parseInteger(cells[6]),
      fausses: parseInteger(cells[7]),
      percentile_fausses: parseInteger(cells[8]),
      aberrantes: parseInteger(cells[9]),
    });
  }
  return result;
}

function extractGlobalIndices(plainText: string): FlexibiliteGlobalIndices {
  const indices: FlexibiliteGlobalIndices = {
    index_prestation_valeur: null,
    index_prestation_percentile: null,
    index_speed_accuracy_valeur: null,
    index_speed_accuracy_percentile: null,
  };

  const prestationMatch = plainText.match(/Index de prestation[^:]*:\s*([-\d,\.]+)\s*\(%?\s*=?\s*(\d+)\)/i);
  if (prestationMatch) {
    indices.index_prestation_valeur = parseNumber(prestationMatch[1]);
    indices.index_prestation_percentile = parseInteger(prestationMatch[2]);
  }

  const speedAccMatch = plainText.match(/Index de.*speed.accuracy[^:]*:\s*([-\d,\.]+)\s*\(%?\s*=?\s*(\d+)\)/i);
  if (speedAccMatch) {
    indices.index_speed_accuracy_valeur = parseNumber(speedAccMatch[1]);
    indices.index_speed_accuracy_percentile = parseInteger(speedAccMatch[2]);
  }

  return indices;
}

// ── Main entry point ────────────────────────────────────────────────────────

export function parseTapRtfContent(content: string): TapParseResult | null {
  const isRtf = content.trimStart().startsWith('{\\rtf');

  // Detect test type from raw content (works on both RTF and plain text)
  const testInfo = detectTestType(isRtf ? decodeRtfHex(content) : content);
  if (!testInfo) return null;

  if (isRtf) {
    // ── RTF path: cell-based extraction ──
    const plainText = stripRtfToPlainText(content);
    const lines = plainText.split('\n');
    const metadata = extractMetadata(lines);

    // Refine typeTest from the line after the test name header
    for (let i = 0; i < Math.min(lines.length, 5); i++) {
      const trimmed = lines[i].trim();
      if (testInfo.type === 'attention_soutenue' && /^Couleur/i.test(trimmed)) {
        testInfo.typeTest = trimmed;
      }
      if (testInfo.type === 'flexibilite' && /^Alternance/i.test(trimmed)) {
        testInfo.typeTest = trimmed;
      }
    }

    const tableRows = parseRtfTableRows(content);

    if (testInfo.type === 'attention_soutenue') {
      return {
        testType: 'attention_soutenue',
        typeTest: testInfo.typeTest,
        metadata,
        attentionRows: buildAttentionRows(tableRows),
      };
    }

    const globalIndices = extractGlobalIndices(plainText);
    return {
      testType: 'flexibilite',
      typeTest: testInfo.typeTest,
      metadata,
      flexibiliteRows: buildFlexibiliteRows(tableRows),
      globalIndices,
    };
  }

  // ── Plain text path (pasted text, not RTF) ──
  const lines = content.split('\n');
  const metadata = extractMetadata(lines);

  for (let i = 0; i < Math.min(lines.length, 5); i++) {
    const trimmed = lines[i].trim();
    if (testInfo.type === 'attention_soutenue' && /^Couleur/i.test(trimmed)) {
      testInfo.typeTest = trimmed;
    }
    if (testInfo.type === 'flexibilite' && /^Alternance/i.test(trimmed)) {
      testInfo.typeTest = trimmed;
    }
  }

  // Build rows from tab-separated or line-by-line plain text
  const plainTextRows = parsePlainTextTable(lines, testInfo.type);

  if (testInfo.type === 'attention_soutenue') {
    return {
      testType: 'attention_soutenue',
      typeTest: testInfo.typeTest,
      metadata,
      attentionRows: buildAttentionRows(plainTextRows),
    };
  }

  const globalIndices = extractGlobalIndices(content);
  return {
    testType: 'flexibilite',
    typeTest: testInfo.typeTest,
    metadata,
    flexibiliteRows: buildFlexibiliteRows(plainTextRows),
    globalIndices,
  };
}

// ── Plain text table parser (for non-RTF input) ────────────────────────────
function parsePlainTextTable(lines: string[], testType: TapTestType): string[][] {
  const rows: string[][] = [];
  const isConditionStart = testType === 'attention_soutenue' ? isAttentionCondition : isFlexCondition;
  const expectedCols = testType === 'attention_soutenue' ? 12 : 10;

  let i = 0;
  // Skip to past "Condition" header
  while (i < lines.length && lines[i].trim() !== 'Condition') i++;
  if (i >= lines.length) return rows;
  i++;

  // Skip sub-header lines until first data
  while (i < lines.length && !isConditionStart(lines[i].trim())) i++;

  while (i < lines.length) {
    const trimmed = lines[i].trim();
    if (!trimmed) { i++; continue; }
    if (/En caract/i.test(trimmed)) break;

    if (trimmed.includes('\t') && isConditionStart(trimmed)) {
      const cells = trimmed.split('\t').map(c => c.trim());
      if (cells.length >= expectedCols) {
        rows.push(cells);
        i++;
        continue;
      }
    }

    if (isConditionStart(trimmed)) {
      const values: string[] = [trimmed];
      let j = i + 1;
      while (values.length < expectedCols && j < lines.length) {
        const nextLine = lines[j].trim();
        if (/En caract/i.test(nextLine) || isConditionStart(nextLine)) break;
        if (nextLine) values.push(nextLine);
        j++;
      }
      if (values.length >= expectedCols) rows.push(values);
      i = j;
      continue;
    }

    i++;
  }

  return rows;
}
